// 1)compiling Vertex shader
unsigned int vertexShader; // our openGL ID for vertex shader
vertexShader = glCreateShader(GL_VERTEX_SHADER); //shader object referenced by an ID
glShaderSource(vertexShader, 1, &vertexShaderSource, NULL); // attach the shader source code to the shader object
glCompileShader(vertexShader); // compile the shader

// check successful compilation

int success; // success indicator
char infoLog[512]; // storage container for the error message
glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success); // check compilation status of vertexShader

if (!success)
{
	glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); // write information log for a shader object into infoLog[512] array
	std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
}
/*------------------------------------------------------------------------------------------------------*/

// 2)compiling Fragment shader
unsigned int fragmentShader; // our openGL ID for fragment shader
fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); // generate ID for fragment shader
glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL); // attach the shader source code to shader object
glCompileShader(fragmentShader); // compile the shader


// there are no code for check succcessful compilation of fragment shader

/*------------------------------------------------------------------------------------------------------*/

// 3)Shader program combination of two compiled shaders

unsigned int shaderProgram; // openGL ID of shaderProgram
shaderProgram = glCreateProgram(); // generate ID for our shaderProgram

glAttachShader(shaderProgram, vertexShader); // attach vertex to shaderProgram
glAttachShader(shaderProgram, fragmentShader); // attach fragment shader to shaderProgram
glLinkProgram(shaderProgram); // link code together

// check succcessful linking

glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
if(!success) 
{
	glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
	std::cout << "ERROR::shaderProgram::LINKING_FAILED\n" << infoLog << std::endl;
}


// Total using of this program in Render pipeline
glUseProgram(shaderProgram);

// free resources vertexShader & fragmentShader

glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);

/*------------------------------------------------------------------------------------------------------*/

// Linking vertex attributes (interpete vertex data)
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);






unsigned int VAO;
glGenVertexArrays(1, &VAO);
// 1. bind Vertex Array Object
glBindVertexArray(VAO);
// 2. copy our vertices array in a buffer for OpenGL to use
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 3. then set our vertex attributes pointers
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
// 4. draw the object
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
glDrawArrays(GL_TRIANGLES, 0, 3);





























